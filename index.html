<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Vigenère Cipher Tool</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9; }
    h2 { color: #333; }
    textarea, input { width: 100%; margin-top: 5px; margin-bottom: 15px; padding: 8px; font-size: 1em; }
    button { padding: 10px 15px; font-size: 1em; margin-right: 10px; cursor: pointer; }
    .output { white-space: pre-wrap; background: #fff; padding: 10px; border: 1px solid #ccc; min-height: 100px; }
    canvas { margin-top: 20px; }
  </style>
</head>
<body><h2>Vigenère Cipher Tool</h2><label>Input Text:</label>

<textarea id="inputText" rows="4" oninput="updateFrequencyChart()"></textarea><label>Key (for Encrypt/Decrypt):</label> <input type="text" id="key">

<div>
  <button onclick="encrypt()">Encrypt</button>
  <button onclick="decrypt()">Decrypt</button>
  <button onclick="bruteForce()">Bruteforce Crack</button>
  <button onclick="autoCrack()">AutoCrack</button>
  <button onclick="estimateKeyLength()">Estimate Key Length</button>
</div><h3>Output:</h3>
<div class="output" id="output"></div><canvas id="freqChart" width="600" height="300"></canvas>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script><script>
function vigenere(text, key, encrypt = true) {
  text = text.toUpperCase().replace(/[^A-Z]/g, '');
  key = key.toUpperCase().replace(/[^A-Z]/g, '');
  let result = '', keyIndex = 0;

  for (let i = 0; i < text.length; i++) {
    let charCode = text.charCodeAt(i) - 65;
    let keyCode = key.charCodeAt(keyIndex % key.length) - 65;
    if (!encrypt) keyCode = -keyCode;
    let newChar = String.fromCharCode(((charCode + keyCode + 26) % 26) + 65);
    result += newChar;
    keyIndex++;
  }
  return result;
}

function encrypt() {
  const text = document.getElementById('inputText').value;
  const key = document.getElementById('key').value;
  const result = vigenere(text, key, true);
  document.getElementById('output').textContent = result;
  updateFrequencyChart(result);
}

function decrypt() {
  const text = document.getElementById('inputText').value;
  const key = document.getElementById('key').value;
  const result = vigenere(text, key, false);
  document.getElementById('output').textContent = result;
  updateFrequencyChart(result);
}

const commonWords = ["THE", "AND", "THAT", "HAVE", "FOR", "NOT", "WITH", "YOU", "THIS", "BUT"];

function scoreEnglish(text) {
  let score = 0;
  for (let word of commonWords) {
    if (text.includes(word)) score++;
  }
  return score;
}

function bruteForce() {
  const text = document.getElementById('inputText').value;
  let best = { score: 0, key: '', result: '' };

  for (let len = 1; len <= 3; len++) {
    let max = Math.pow(26, len);
    for (let i = 0; i < max; i++) {
      let key = '';
      let n = i;
      for (let j = 0; j < len; j++) {
        key = String.fromCharCode((n % 26) + 65) + key;
        n = Math.floor(n / 26);
      }
      let decrypted = vigenere(text, key, false);
      let score = scoreEnglish(decrypted);
      if (score > best.score) {
        best = { score, key, result: decrypted };
      }
    }
  }
  document.getElementById('output').textContent = best.result ? `Best Key: ${best.key}\nDecrypted: ${best.result}` : 'No match found.';
  updateFrequencyChart(best.result);
}

function autoCrack() {
  const text = document.getElementById('inputText').value;
  const sampleKeys = ["KEY", "SECRET", "VIGENERE", "HELLO", "WORLD"];
  let best = { score: 0, key: '', result: '' };

  for (let key of sampleKeys) {
    let decrypted = vigenere(text, key, false);
    let score = scoreEnglish(decrypted);
    if (score > best.score) {
      best = { score, key, result: decrypted };
    }
  }
  document.getElementById('output').textContent = best.result ? `Guessed Key: ${best.key}\nDecrypted: ${best.result}` : 'No likely match found.';
  updateFrequencyChart(best.result);
}

function estimateKeyLength() {
  const text = document.getElementById('inputText').value.toUpperCase().replace(/[^A-Z]/g, '');
  const N = text.length;
  const freq = Array(26).fill(0);

  for (let i = 0; i < N; i++) freq[text.charCodeAt(i) - 65]++;

  const ic = freq.reduce((sum, f) => sum + f * (f - 1), 0) / (N * (N - 1));
  const estimatedKeyLength = 0.027 * N / ((N - 1) * ic - 0.038 * N + 0.065);
  const rounded = Math.round(estimatedKeyLength);

  document.getElementById('output').textContent = `Estimated Key Length (Friedman Test): ${rounded}\n(IC = ${ic.toFixed(4)})`;
}

// Frequency Chart
let chart;
const englishFreq = [8.2, 1.5, 2.8, 4.3, 13.0, 2.2, 2.0, 6.1, 7.0, 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0, 6.3, 9.1, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1];

function updateFrequencyChart(text = '') {
  text = text.toUpperCase().replace(/[^A-Z]/g, '');
  const freq = Array(26).fill(0);
  for (let char of text) {
    freq[char.charCodeAt(0) - 65]++;
  }
  const total = freq.reduce((a, b) => a + b, 0);
  const freqPercent = freq.map(v => (total ? (v / total) * 100 : 0));

  const labels = Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i));
  if (chart) {
    chart.data.datasets[0].data = freqPercent;
    chart.update();
  } else {
    const ctx = document.getElementById('freqChart').getContext('2d');
    chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Cipher Text Frequency (%)',
            data: freqPercent,
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          },
          {
            label: 'English Frequency (%)',
            data: englishFreq,
            backgroundColor: 'rgba(255, 99, 132, 0.4)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1
          }
        ]
      },
      options: {
        scales: {
          y: { beginAtZero: true, max: 15 }
        }
      }
    });
  }
}
</script></body>
</html>